# 计算机网络学习笔记 #
## HTTP协议 ##
**http请求**由三部分组成，分别是：请求行、消息报头、请求正文

HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。

- 常用的HTTP方法有哪些？
- 
**GET：** 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。

**POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。

**PUT：** 传输文件，报文主体中包含文件内容，保存到对应URI位置。

**HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。

**DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。

**OPTIONS：**查询相应URI支持的HTTP方法。

- GET方法与POST方法的区别
- 
**区别一：**

get重点在从服务器上获取资源，post重点在向服务器发送数据；


**区别二：**

get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的；
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；


**区别三：**

Get传输的数据量小，因为受URL长度限制，但效率较高；
Post可以传输大量数据，所以上传文件时只能用Post方式；


**区别四：**

get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；
post较get安全性较高；


**区别五：**

get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
post支持标准字符集，可以正确传递中文字符。

- HTTP请求报文与响应报文格式
- 
请求报文包含三部分：

a、请求行：包含请求方法、URI、HTTP版本信息

b、请求首部字段

c、请求内容实体


响应报文包含三部分：

a、状态行：包含HTTP版本、状态码、状态码的原因短语

b、响应首部字段

c、响应内容实体



- 常见的HTTP相应状态码
- 

返回的状态

**1xx：**指示信息--表示请求已接收，继续处理

**2xx：**成功--表示请求已被成功接收、理解、接受

**3xx：**重定向--要完成请求必须进行更进一步的操作

**4xx：**客户端错误--请求有语法错误或请求无法实现

**5xx：**服务器端错误--服务器未能实现合法的请求


----------


*****200：**请求被正常处理***

**204：**请求被受理但没有资源可以返回

**206：**客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。

**301：**永久性重定向

**302：**临时重定向

**303：**与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上

**304：**发送附带条件的请求时，条件不满足时返回，与重定向无关

**307：**临时重定向，与302类似，只是强制要求使用POST方法

*****400：**请求报文语法有误，服务器无法识别***

*****401：**请求需要认证***

*****403：**请求的对应资源禁止被访问***

*****404：**服务器无法找到对应资源***

******500：**服务器内部错误***

*****503：**服务器正忙****

- 常见HTTP首部字段
- 
**a、通用首部字段（请求报文与响应报文都会使用的首部字段）**

Date：创建报文时间

Connection：连接的管理

Cache-Control：缓存的控制

Transfer-Encoding：报文主体的传输编码方式

**b、请求首部字段（请求报文会使用的首部字段）**

Host：请求资源所在服务器

Accept：可处理的媒体类型

Accept-Charset：可接收的字符集

Accept-Encoding：可接受的内容编码

Accept-Language：可接受的自然语言

**c、响应首部字段（响应报文会使用的首部字段）**

Accept-Ranges：可接受的字节范围

Location：令客户端重新定向到的URI

Server：HTTP服务器的安装信息

**d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）**

Allow：资源可支持的HTTP方法

Content-Type：实体主类的类型

Content-Encoding：实体主体适用的编码方式

Content-Language：实体主体的自然语言

Content-Length：实体主体的的字节数

Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

- HTTP缺点与HTTPS
- 
a、通信使用明文不加密，内容可能被窃听

b、不验证通信方身份，可能遭到伪装

c、无法验证报文完整性，可能被篡改

HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护。

1） https协议要申请证书到ca，需要一定经济成本；

2） http是明文传输，https是加密的安全传输；

3） 连接的端口不一样，http是80，https是443；

4）http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。

- HTTP中与缓存有关的字段
- 

**Expires**、**Cache-Control**、**Last-Modified**、 **ETag**是RFC 2616（HTTP/1.1）协议中和网页缓存相关的几个字段。

前两个用来**控制缓存的失效日期**，后两个用来**验证网页的有效性**。

**Expires字段**声明了一个网页或URL地址不再被浏览器缓存的时间，一旦超过了这个时间，浏览器都应该联系原始服务器。RFC告诉我们：“由于推断的失效时间也许会降低语义透明度，应该被谨慎使用，同时我们鼓励原始服务器尽可能提供确切的失效时间。”

**Cache-Control字段**中可以声明多些元素，例如no-cache, must-revalidate, max-age=0等。这些元素用来指明页面被缓存最大时限，如何被缓存的，如何被转换到另一个不同的媒介，以及如何被存放在持久媒介中的。但是任何一个 Cache-Control指令都不能保证隐私性或者数据的安全性。“private”和“no-store”指令可以为隐私性和安全性方面提供一些帮助，但是他们并不能用于替代身份验证和加密

**max-age=[秒]** — 执行缓存被认为是最新的最长时间。类似于过期时间，这个参数是基于请求时间的相对时间间隔，而不是绝对过期时间，[秒]是一个数字，单位是秒：从请求时间开始到过期时间之间的秒数。

**s-maxage=[秒]** — 类似于max-age属性，除了他应用于共享（如：代理服务器）缓存

**public** — 标记认证内容也可以被缓存，一般来说： 经过HTTP认证才能访问的内容，输出是自动不可以缓存的；

**no-cache** — 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和public结合使用），或者严格要求使用最新数据的应用（不惜牺牲使用缓存的所有好处）；

**no-store** — 强制缓存在任何情况下都不要保留任何副本

**must-revalidate** — 告诉缓存必须遵循所有你给予副本的新鲜度的，HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，你高速缓存，你希望严格的遵循你的规则。

**proxy-revalidate** — 和 must-revalidate类似，除了他只对缓存代理服务器起作用

**Expires/Cache-Control Header**是控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只是Cache-Control比Expires可以控制的多一些，而且Cache-Control会重写Expires的规则。

**Last-Modified/If-Modified-Since**和**ETag/If-None-Match**是浏览器发送请求到服务器后判断文件是否已经修改过，如果没有修改过就只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器

- http1.0与1.1的区别
- 


1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。


1. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。


1. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。


1. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。


1. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

- http2.0与1.x的区别
- 



1. **新的二进制格式（Binary Format）**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。



1. **多路复用（MultiPlexing）**，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。



1. **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。



1. **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

## HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ ##

**HTTP/1.*** 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

**HTTP/1.1** Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

**HTTP/2**多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；